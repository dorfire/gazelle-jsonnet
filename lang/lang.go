package jsonnet

import (
	"io/ioutil"
	"log"
	"path"
	"regexp"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

const (
	jsonnetName          = "jsonnet"
	jsonnetExt           = ".jsonnet"
	jsonnetLibExt        = ".libsonnet"
	jsonnetLibVisibility = "//visibility:public"
)

type jsonnetLang struct{}

var (
	jsonnetImportPattern = regexp.MustCompile(`import\s+'([\w\/.]+)'`)
)

// NewLanguage returns a new instance of the Jsonnet language extension for Gazelle.
func NewLanguage() language.Language {
	return &jsonnetLang{}
}

// Loads returns .bzl files and symbols they define. Every rule generated by
// GenerateRules, now or in the past, should be loadable from one of these
// files.
func (*jsonnetLang) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		{Name: "@io_bazel_rules_jsonnet//jsonnet:jsonnet.bzl", Symbols: []string{"jsonnet_library", "jsonnet_to_json"}},
	}
}

// Kinds returns a map of rule names (kinds) and information on how to
// match and merge attributes that may be found in rules of those kinds.
func (*jsonnetLang) Kinds() map[string]rule.KindInfo {
	return map[string]rule.KindInfo{
		"jsonnet_to_json": {
			MergeableAttrs: map[string]bool{"src": true, "outs": true},
			ResolveAttrs:   map[string]bool{"deps": true},
		},
		"jsonnet_library": {
			MergeableAttrs: map[string]bool{"visibility": true},
		},
	}
}

// GenerateRules extracts build metadata from source files in a directory.
// Called in each directory where an update is requested in depth-first post-order.
// Any non-fatal errors this function encounters should be logged using `log.Print`.
func (*jsonnetLang) GenerateRules(args language.GenerateArgs) (res language.GenerateResult) {
	if !shouldProcessPkg(args.Rel) {
		return
	}

	jsonnetFiles := findJsonnetsAndLibsonnets(args.RegularFiles)

	for _, fName := range jsonnetFiles {
		// Both .jsonnet and .libsonnet files may import other .libsonnet files
		imports, err := parseJsonnetImports(path.Join(args.Dir, fName))
		if err != nil {
			log.Print("jsonnet: could not parse file: ", err)
			continue
		}

		var r *rule.Rule
		switch path.Ext(fName) {
		case jsonnetExt:
			r = newJsonnetRule(fName)
			break
		case jsonnetLibExt:
			r = newJsonnetLibraryRule(fName)
			break
		default:
			log.Printf("jsonnet: invalid file name '%s'", fName)
			continue
		}

		// Gen is a list of rules generated from files found in the directory
		// GenerateRules was asked to process. These will be merged with existing rules or added to the build file.
		res.Gen = append(res.Gen, r)
		// `res.Imports` contains information about the imported libraries for each rule in Gen.
		// Gen and Imports must have the same length, since they correspond. These values are passed to Resolve after merge.
		res.Imports = append(res.Imports, imports)
	}

	return
}

// Fix is required to satisfy the interface language.Language. Unused by this language.
func (*jsonnetLang) Fix(_ *config.Config, _ *rule.File) {
}

func newJsonnetRule(src string) *rule.Rule {
	outName := strings.Replace(src, jsonnetExt, ".json", 1)
	labelName := strings.ReplaceAll(outName, ".", "_")

	res := rule.NewRule("jsonnet_to_json", labelName)
	res.SetAttr("src", src)
	res.SetAttr("outs", []string{outName})

	return res
}

func newJsonnetLibraryRule(src string) *rule.Rule {
	labelName := strings.TrimSuffix(src, jsonnetLibExt)

	res := rule.NewRule("jsonnet_library", labelName)
	res.SetAttr("srcs", []string{src})
	res.SetAttr("visibility", []string{jsonnetLibVisibility})

	return res
}

// findJsonnetsAndLibsonnets iterates a directory and returns a slice of the .jsonnet/.libsonnet files in it.
func findJsonnetsAndLibsonnets(regularFiles []string) (res []string) {
	for _, f := range regularFiles {
		if strings.HasSuffix(f, jsonnetExt) || strings.HasSuffix(f, jsonnetLibExt) {
			res = append(res, f)
		}
	}
	return
}

func parseJsonnetImports(filePath string) (res []string, err error) {
	fileContent, err := ioutil.ReadFile(filePath)
	if err != nil {
		return
	}

	importStmts := jsonnetImportPattern.FindAllSubmatch(fileContent, -1)
	for _, stmt := range importStmts {
		res = append(res, string(stmt[1]))
	}
	return
}
